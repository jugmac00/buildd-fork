#!/usr/bin/python -u
# Copyright 2010, 2011 Canonical Ltd.  This software is licensed under the
# GNU Affero General Public License version 3 (see the file LICENSE).

"""A script that builds a package from a recipe and a chroot."""

__metaclass__ = type


import os
import os.path
import pwd
from resource import RLIMIT_AS, setrlimit
import socket
from subprocess import (
    Popen,
    call,
    check_call,
    )
import sys


RETCODE_SUCCESS = 0
RETCODE_FAILURE_INSTALL = 200
RETCODE_FAILURE_BUILD_TREE = 201
RETCODE_FAILURE_INSTALL_BUILD_DEPS = 202
RETCODE_FAILURE_BUILD_SOURCE_PACKAGE = 203


class NotVirtualized(Exception):
    """Exception raised when not running in a virtualized environment."""

    def __init__(self):
        Exception.__init__(self, 'Not running under Xen.')


def call_report_rusage(args, env):
    """Run a subprocess.

    Report that it was run, and the resources used, and complain if it fails.

    :return: The process wait status.
    """
    print 'RUN %r' % args
    proc = Popen(args, env=env)
    pid, status, rusage = os.wait4(proc.pid, 0)
    print(rusage)
    return status


class RecipeBuilder:
    """Builds a package from a recipe."""

    def __init__(self, build_id, author_name, author_email,
                 suite, distroseries_name, component, archive_purpose):
        """Constructor.

        :param build_id: The id of the build (a str).
        :param author_name: The name of the author (a str).
        :param author_email: The email address of the author (a str).
        :param suite: The suite the package should be built for (a str).
        """
        self.build_id = build_id
        self.author_name = author_name.decode('utf-8')
        self.author_email = author_email
        self.archive_purpose = archive_purpose
        self.component = component
        self.distroseries_name = distroseries_name
        self.suite = suite
        self.base_branch = None
        self.chroot_path = get_build_path(build_id, 'chroot-autobuild')
        self.work_dir_relative = os.environ['HOME'] + '/work'
        self.work_dir = os.path.join(self.chroot_path,
                                     self.work_dir_relative[1:])
        self.tree_path = os.path.join(self.work_dir, 'tree')
        self.username = pwd.getpwuid(os.getuid())[0]

    def install(self):
        """Install all the requirements for building recipes.

        :return: A retcode from apt.
        """
        # XXX: AaronBentley 2010-07-07 bug=602463: pbuilder uses aptitude but
        # does not depend on it.
        return self.chroot([
            'apt-get', 'install', '-y', 'pbuilder', 'aptitude'])

    def buildTree(self):
        """Build the recipe into a source tree.

        As a side-effect, sets self.source_dir_relative.
        :return: a retcode from `bzr dailydeb`.
        """
        try:
            ensure_virtualized()
        except NotVirtualized, e:
            sys.stderr.write('Aborting on failed virtualization check:\n')
            sys.stderr.write(str(e))
            return 1
        assert not os.path.exists(self.tree_path)
        recipe_path = os.path.join(self.work_dir, 'recipe')
        manifest_path = os.path.join(self.tree_path, 'manifest')
        recipe_file = open(recipe_path, 'rb')
        try:
            recipe = recipe_file.read()
        finally:
            recipe_file.close()
        # As of bzr 2.2, a defined identity is needed.  In this case, we're
        # using buildd@<hostname>.
        hostname = socket.gethostname()
        bzr_email = 'buildd@%s' % hostname

        print 'Bazaar versions:'
        check_call(['bzr', 'version'])
        check_call(['bzr', 'plugins'])

        print 'Building recipe:'
        print recipe
        sys.stdout.flush()
        env = {
            'DEBEMAIL': self.author_email,
            'DEBFULLNAME': self.author_name.encode('utf-8'),
            'BZR_EMAIL': bzr_email}
        retcode = call_report_rusage([
            'bzr', 'dailydeb', '--safe', '--no-build', recipe_path,
            self.tree_path, '--manifest', manifest_path,
            '--allow-fallback-to-native', '--append-version',
            '~%s1' % self.distroseries_name], env=env)
        if retcode != 0:
            return retcode
        (source,) = [name for name in os.listdir(self.tree_path)
                     if os.path.isdir(os.path.join(self.tree_path, name))]
        self.source_dir_relative = os.path.join(
            self.tree_path, source)
        return retcode

    def getPackageName(self):
        source_dir = os.path.join(
            self.chroot_path, self.source_dir_relative.lstrip('/'))
        changelog = os.path.join(source_dir, 'debian/changelog')
        return open(changelog, 'r').readline().split(' ')[0]

    def installBuildDeps(self):
        """Install the build-depends of the source tree."""
        package = self.getPackageName()
        currently_building_path = os.path.join(
            self.chroot_path, 'CurrentlyBuilding')
        currently_building_contents = (
            'Package: %s\n'
            'Suite: %s\n'
            'Component: %s\n'
            'Purpose: %s\n'
            'Build-Debug-Symbols: no\n' %
            (package, self.suite, self.component, self.archive_purpose))
        currently_building = open(currently_building_path, 'w')
        currently_building.write(currently_building_contents)
        currently_building.close()
        return self.chroot(['sh', '-c', 'cd %s &&'
                     '/usr/lib/pbuilder/pbuilder-satisfydepends'
                     % self.source_dir_relative])

    def chroot(self, args, echo=False):
        """Run a command in the chroot.

        :param args: the command and arguments to run.
        :return: the status code.
        """
        if echo:
            print "Running in chroot: %s" % ' '.join(
                "'%s'" % arg for arg in args)
            sys.stdout.flush()
        return call([
            '/usr/bin/sudo', '/usr/sbin/chroot', self.chroot_path] + args)

    def buildSourcePackage(self):
        """Build the source package.

        :return: a retcode from dpkg-buildpackage.
        """
        retcode = self.chroot([
            'su', '-c', 'cd %s && /usr/bin/dpkg-buildpackage -i -I -us -uc -S'
            % self.source_dir_relative, self.username])
        for filename in os.listdir(self.tree_path):
            path = os.path.join(self.tree_path, filename)
            if os.path.isfile(path):
                os.rename(path, get_build_path(self.build_id, filename))
        return retcode


def get_build_path(build_id, *extra):
    """Generate a path within the build directory.

    :param build_id: the build id to use.
    :param extra: the extra path segments within the build directory.
    :return: the generated path.
    """
    return os.path.join(
        os.environ["HOME"], "build-" + build_id, *extra)


def ensure_virtualized():
    """Raise an exception if not running in a virtualized environment.

    Raises if not running under Xen.
    """
    if not os.path.isdir('/proc/xen') or os.path.exists('/proc/xen/xsd_kva'):
        raise NotVirtualized()


if __name__ == '__main__':
    setrlimit(RLIMIT_AS, (1000000000, -1))
    builder = RecipeBuilder(*sys.argv[1:])
    if builder.buildTree() != 0:
        sys.exit(RETCODE_FAILURE_BUILD_TREE)
    if builder.install() != 0:
        sys.exit(RETCODE_FAILURE_INSTALL)
    if builder.installBuildDeps() != 0:
        sys.exit(RETCODE_FAILURE_INSTALL_BUILD_DEPS)
    if builder.buildSourcePackage() != 0:
        sys.exit(RETCODE_FAILURE_BUILD_SOURCE_PACKAGE)
    sys.exit(RETCODE_SUCCESS)
